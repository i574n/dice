/// # dice_contract
open rust
open rust.rust_operators

/// ## dice_contract

/// ### state
type state =
    {
        version : u32
        seeds : near.vector u8
    }

/// ### new
inl new () : state =
    {
        version = 1
        seeds = "seeds" |> sm'.byte_slice |> near.new_vector
    }

/// ### main
///! _

inl max_seeds () : unativeint =
    100i32 |> convert

inl main () =
    !\($'"} //"') : ()

    inl util () =
        !\($'"pub struct Util {} //"') : ()
        !\($'"impl Util { //"') : ()
        !\($'"    fn stream_u8_to_list( //"') : ()
        !\($'"        s: fable_library_rust::Native_::LrcPtr<dice_contract_lib::Dice::UH0>, //"') : ()
        !\($'"    ) -> dice_contract_lib::Dice::UH1 { //"') : ()
        !\($'"        match s.as_ref() { //"') : ()
        !\($'"            dice_contract_lib::Dice::UH0::UH0_0(n, f) => { //"') : ()
        !\($'"                dice_contract_lib::Dice::UH1::UH1_1(*n, Self::stream_u8_to_list(f()).into()) //"') : ()
        !\($'"            } //"') : ()
        !\($'"            dice_contract_lib::Dice::UH0::UH0_1 => dice_contract_lib::Dice::UH1::UH1_0, //"') : ()
        !\($'"        } //"') : ()
        !\($'"    } //"') : ()
        !\($'"    fn list_u8_to_vec( //"') : ()
        !\($'"        s: fable_library_rust::Native_::LrcPtr<dice_contract_lib::Dice::UH1>, //"') : ()
        !\($'"    ) -> Vec<u8> { //"') : ()
        !\($'"        match s.as_ref() { //"') : ()
        !\($'"            dice_contract_lib::Dice::UH1::UH1_1(n, f) => { //"') : ()
        !\($'"                let mut v = Self::list_u8_to_vec(f.clone()); //"') : ()
        !\($'"                v.insert(0, *n); //"') : ()
        !\($'"                v //"') : ()
        !\($'"            } //"') : ()
        !\($'"            dice_contract_lib::Dice::UH1::UH1_0 => vec\![], //"') : ()
        !\($'"        } //"') : ()
        !\($'"    } //"') : ()
        !\($'"    fn vec_u8_to_list(v: Vec<u8>) -> dice_contract_lib::Dice::UH1 { //"') : ()
        !\($'"        v.iter() //"') : ()
        !\($'"            .rev() //"') : ()
        !\($'"            .fold(dice_contract_lib::Dice::UH1::UH1_0, |acc, x| { //"') : ()
        !\($'"                dice_contract_lib::Dice::UH1::UH1_1(*x, acc.into()) //"') : ()
        !\($'"            }) //"') : ()
        !\($'"    } //"') : ()
        !\($'"    fn vec_u8_to_stream(v: Vec<u8>) -> dice_contract_lib::Dice::UH0 { //"') : ()
        !\($'"        v.iter() //"') : ()
        !\($'"            .rev() //"') : ()
        !\($'"            .fold(dice_contract_lib::Dice::UH0::UH0_1, |acc, x| { //"') : ()
        !\($'"                dice_contract_lib::Dice::UH0::UH0_0( //"') : ()
        !\($'"                    *x, //"') : ()
        !\($'"                    fable_library_rust::Native_::Func0::new(move || acc.clone().into()), //"') : ()
        !\($'"                ) //"') : ()
        !\($'"            }) //"') : ()
        !\($'"    } //"') : ()
        !\($'"} //"') : ()

    util ()


    !\($'"#[derive( //"') : ()
    !\($'"  near_sdk::PanicOnDefault, //"') : ()
    !\($'"  borsh::BorshDeserialize, //"') : ()
    !\($'"  borsh::BorshSerialize, //"') : ()
    !\($'")] //"') : ()

    !\($'"pub struct OldState { //"') : ()
    !\($'"    version: u32, //"') : ()
    !\($'"    seeds: near_sdk::store::vec::Vector<u8>, //"') : ()
    !\($'"} //"') : ()

    !\($'"#[near_sdk::near_bindgen] //"') : ()

    !\($'"#[derive( //"') : ()
    !\($'"  near_sdk::PanicOnDefault, //"') : ()
    !\($'"  borsh::BorshDeserialize, //"') : ()
    !\($'"  borsh::BorshSerialize, //"') : ()
    !\($'")] //"') : ()

    !\($'"pub struct State ( //"') : ()

    !\($'"/*"') : ()
    (null () : rust.type_emit state) |> ignore
    !\($'"*/ )"') : ()

    !\($'"impl From<OldState> for State { //"') : ()
    !\($'"    fn from(old_state: OldState) -> Self { //"') : ()
    !\($'"        Self((old_state.version, old_state.seeds)) //"') : ()
    !\($'"    } //"') : ()
    !\($'"} //"') : ()

    inl new_ () =
        !\($'"#[init] //"') : ()
        !\($'"pub fn new() -> Self { // 1"') : ()

        (!\($'"true; /*"') : bool) |> ignore

        (null () : rust.type_emit ()) |> ignore

        (!\($'"true; */"') : bool) |> ignore

        inl result = new ()
        $'let _result = !result in _result |> (fun x -> Fable.Core.RustInterop.emitRustExpr x $"Self($0) // x") // 2' : ()

        !\($'"} // 2."') : ()

        !\($'"} // 1."') : ()

        2

    inl contribute_seed () =
        !\($'"pub fn contribute_seed(&mut self, seed: Vec<u8>) { //"') : ()
        inl seeds : rust.ref (rust.mut' (near.vector u8)) =
            !\($'$"&mut self.0.1"')

        !\($'"    !seeds.extend(seed); //"') : ()
        inl max_seeds = max_seeds ()
        !\($'"    let seed_excess_len = (!seeds.len() as i32) - !max_seeds as i32; //"') : ()
        !\($'"    if seed_excess_len > 0 { //"') : ()
        !\($'"        let seed_excess: Vec<_> = !seeds.drain(0..seed_excess_len as u32).collect(); //"') : ()
        !\($'"        near_sdk::log\!( //"') : ()
        !\($'"            \\\"{}\\\", //"') : ()
        !\($'"            format\!( //"') : ()
        !\($'"                \\\"contribute_seed / seed_excess: {seed_excess:?}\\\" //"') : ()
        !\($'"            ) //"') : ()
        !\($'"        ); //"') : ()
        !\($'"    } //"') : ()
        !\($'"} //"') : ()

        !\($'"} //"') : ()

        !\($'"} //"') : ()

        3

    inl contribute_seed_borsh () =
        !\($'"pub fn contribute_seed_borsh(&mut self, #[serializer(borsh)] seed: Vec<u8>) { //"') : ()
        !\($'"    self.contribute_seed(seed) //"') : ()
        !\($'"} //"') : ()

        1

    inl get_logger () =
        !\($'"fn get_logger() -> fable_library_rust::Native_::Func1<fable_library_rust::String_::string, ()> { //"') : ()
        !\($'"    let count = std::rc::Rc::new(std::cell::RefCell::new(0)); //"') : ()
        !\($'"    let acc = std::rc::Rc::new(std::cell::RefCell::new(String::new())); //"') : ()
        !\($'"    let closure = { //"') : ()
        !\($'"        let count = std::rc::Rc::clone(&count); //"') : ()
        !\($'"        let acc = std::rc::Rc::clone(&acc); //"') : ()
        !\($'"        move |s: fable_library_rust::String_::string| { //"') : ()
        !\($'"            let mut count_ref = count.borrow_mut(); //"') : ()
        !\($'"            let mut acc_ref = acc.borrow_mut(); //"') : ()
        !\($'"            *count_ref += 1; //"') : ()
        !\($'"            if s.len() == 0 || *count_ref % 6 == 0 { //"') : ()
        !\($'"                let lines : String = acc_ref.clone().drain(..acc_ref.len() - 1).collect(); //"') : ()
        !\($'"                near_sdk::log\!(\\\"{}\\\", lines); //"') : ()
        !\($'"                *acc_ref = String::new(); //"') : ()
        !\($'"            } //"') : ()
        !\($'"            acc_ref.push_str(&(s.to_string() + \\\"\n\\\")); //"') : ()
        !\($'"        } //"') : ()
        !\($'"    }; //"') : ()
        !\($'"    fable_library_rust::Native_::Func1::new(closure) //"') : ()
        !\($'"} //"') : ()

        1

    inl generate_random_number () =
        !\($'"pub fn generate_random_number(&mut self, key: String, proof: String, max: u64) -> u64 { //"') : ()
        inl seeds : rust.ref (near.vector u8) =
            !\($'$"&self.0.1"')
        inl seeds : am'.vec u8 = !\($'$"!seeds.iter().map(|x| *x).collect::<Vec<u8>>()"')
        !\($'"    let seed = near_sdk::env::random_seed(); //"') : ()
        !\($'"    let block_timestamp = near_sdk::env::block_timestamp(); //"') : ()
        !\($'"    let signer_account_id = near_sdk::env::signer_account_id(); //"') : ()
        !\($'"    let account_balance = near_sdk::env::account_balance(); //"') : ()
        !\($'"    let block_height = near_sdk::env::block_height(); //"') : ()
        !\($'"    let epoch_height = near_sdk::env::epoch_height(); //"') : ()
        !\($'"    let entropy: Vec<u8> = vec\![ //"') : ()
        !\($'"        seed.clone(), //"') : ()
        !\($'"        !seeds.clone(), //"') : ()
        !\($'"        epoch_height.to_le_bytes().to_vec(), //"') : ()
        !\($'"        block_height.to_le_bytes().to_vec(), //"') : ()
        !\($'"        block_timestamp.to_le_bytes().to_vec(), //"') : ()
        !\($'"        account_balance.as_yoctonear().to_le_bytes().to_vec(), //"') : ()
        !\($'"        signer_account_id.as_bytes().to_vec(), //"') : ()
        !\($'"        proof.clone().into_bytes(), //"') : ()
        !\($'"        key.clone().into_bytes(), //"') : ()
        !\($'"    ].concat(); //"') : ()
        !\($'"    let entropy_len = entropy.len(); //"') : ()
        !\($'"    let hash_u8 = near_sdk::env::keccak512(&entropy); //"') : ()
        !\($'"    self.contribute_seed(hash_u8.clone()); //"') : ()
        !\($'"    let hash_stream = Util::vec_u8_to_stream(hash_u8.clone()); //"') : ()
        !\($'"    let rolls_list = Util::stream_u8_to_list(dice_contract_lib::Dice::rotate_numbers(6)( //"') : ()
        !\($'"        hash_stream.into(), //"') : ()
        !\($'"    )); //"') : ()
        !\($'"    { //"') : ()
        !\($'"        let rolls_list_log = Util::list_u8_to_vec(rolls_list.clone().into()); //"') : ()
        !\($'"        let signer_account_id_log = signer_account_id.as_str(); //"') : ()
        !\($'"        near_sdk::log\!( //"') : ()
        !\($'"            \\\"{}\\\", /* /*"') : ()
        !\($'"            */ format\!(\\\"generate_random_number / max: {max:?} / key: {key:?} / proof: {proof:?} / block_timestamp: {block_timestamp:?} / block_height: {block_height:?} / epoch_height: {epoch_height:?} / account_balance: {account_balance:?} / signer_account_id: {signer_account_id_log:?} / seed: {seed:?} / seeds: {!seeds:?} / entropy_len: {entropy_len:?} / entropy: {entropy:?} / hash_u8: {hash_u8:?} / rolls_list: {rolls_list_log:?}\\\") //"') : ()
        !\($'"        ); //"') : ()
        !\($'"    let logger = Self::get_logger(); //"') : ()
        !\($'"    let sequential_roll = dice_contract_lib::Dice::create_sequential_roller(Some( //"') : ()
        !\($'"        logger.clone(), //"') : ()
        !\($'"    ))(rolls_list.into()); //"') : ()
        !\($'"    let result = dice_contract_lib::Dice::roll_progressively(Some(logger.clone()))( //"') : ()
        !\($'"        sequential_roll, //"') : ()
        !\($'"    )(true)(max); //"') : ()
        !\($'"    logger(\\\"\\\".into()); //"') : ()
        !\($'"    result as u64 //"') : ()
        !\($'"} //"') : ()

        !\($'"} //"') : ()

        !\($'"} //"') : ()

        3

    inl roll_within_bounds () =
        !\($'"pub fn roll_within_bounds(&self, max: u64, rolls: Vec<u8>) -> Option<u64> { //"') : ()
        !\($'"    near_sdk::log\!( //"') : ()
        !\($'"        \\\"{}\\\", //"') : ()
        !\($'"        format\!( //"') : ()
        !\($'"            \\\"roll_within_bounds / max: {max:#?} / rolls: {rolls:?}\\\" //"') : ()
        !\($'"        ) //"') : ()
        !\($'"    ); //"') : ()
        !\($'"    let rolls = Util::vec_u8_to_list(rolls); //"') : ()
        !\($'"    let logger = Self::get_logger(); //"') : ()
        !\($'"    let result = //"') : ()
        !\($'"        dice_contract_lib::Dice::roll_within_bounds(Some(logger.clone()))(max)(rolls.into()); //"') : ()
        !\($'"    logger(\\\"\\\".into()); //"') : ()
        !\($'"    result //"') : ()
        !\($'"} //"') : ()

        1

    inl roll_within_bounds_borsh () =
        !\($'"#[result_serializer(borsh)] //"') : ()
        !\($'"pub fn roll_within_bounds_borsh( //"') : ()
        !\($'"    &self, //"') : ()
        !\($'"    #[serializer(borsh)] max: u64, //"') : ()
        !\($'"    #[serializer(borsh)] rolls: Vec<u8>, //"') : ()
        !\($'") -> Option<u64> { //"') : ()
        !\($'"    self.roll_within_bounds(max, rolls) //"') : ()
        !\($'"} //"') : ()
        
        1


    inl fns =
        [
            new_
            contribute_seed
            contribute_seed_borsh
            get_logger
            generate_random_number
            roll_within_bounds
            roll_within_bounds_borsh
        ]

    inl rec loop acc fns i =
        match fns with
        | [] => acc
        | x :: xs =>
            !\($'"#[near_sdk::near_bindgen] //"') : ()
            !\($'"impl State { //"') : ()
            inl n = x ()
            !\($'"} /* c"') : ()
            inl rec loop' i' =
                if i' <> 1 // <= n
                then (!\($'"true; */ // ???? / i: !i / i\': !i' / acc: !acc / n: !n"') : bool) |> ignore
                else
                    (!\($'"true; // ??? / i: !i / i\': !i' / acc: !acc / n: !n"') : bool) |> ignore
                    loop' (i' + 1)
            loop' 1u8
            loop (acc + n) xs (i + 1)
    inl n = loop 0u8 fns 1u8


    // !\($'"/* a"') : ()

    // !\($'"} // b"') : ()

    !\($'"fn _main() //"') : ()
    !\($'" //"') : ()

    inl rec loop' i' =
        if i' <= n
        then
            (!\($'"true; { (); // ?? / i\': !i' / n: !n"') : bool) |> ignore
            loop' (i' + 1)
        else
            (!\($'"true; { { (); // ? / i\': !i' / n: !n"') : bool) |> ignore
            // (!\($'"true; */ // ?? / i\': !i' / n: !n"') : bool) |> ignore
    loop' 1u8

inl main () =
    $'!main |> ignore' : ()
